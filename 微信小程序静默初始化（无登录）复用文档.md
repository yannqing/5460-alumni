# 微信小程序静默初始化（无登录）复用文档

## 一、概述

本文档详细描述了一个微信小程序的"静默初始化"机制，该机制**无需用户手动登录**，通过调用 `wx.login()` 获取 code，然后发送到后端换取 openid、unionid 等用户信息，并返回 token 用于后续请求鉴权。

### 核心流程图

```
┌─────────────────┐     ┌────────────────┐     ┌─────────────────┐
│  小程序启动      │────▶│  wx.login()    │────▶│  获取微信 code  │
└─────────────────┘     └────────────────┘     └─────────────────┘
                                                        │
                                                        ▼
┌─────────────────┐     ┌────────────────┐     ┌─────────────────┐
│  存储 token     │◀────│  后端返回数据   │◀────│  调用 wx_init   │
│  存储 userData  │     │  (token+用户)   │     │  接口           │
└─────────────────┘     └────────────────┘     └─────────────────┘
```

------

## 二、调用的后端接口清单

### 2.1 初始化相关接口

| 接口名称      | 请求路径                                 | 用途                                                    |
| ------------- | ---------------------------------------- | ------------------------------------------------------- |
| **wx_init**   | `/api/wechat_mini/auth/wx_init`          | **核心接口**：用 wx.login 的 code 换取 token 和用户信息 |
| get_user_info | `/api/wechat_mini_v1/auth/get_user_info` | 刷新/获取用户信息                                       |
| wx_login      | `/api/wechat_mini_v1/auth/wx_login`      | 登录接口（本项目未使用）                                |

### 2.2 wx_init 接口详情

**请求参数：**

```javascript
{
  code: "微信登录code",           // 必填，wx.login() 返回的 code
  inviter_wx_uuid: "邀请人UUID"  // 可选，用于记录邀请关系
}
```

**返回数据结构（需后端配合）：**

```javascript
{
  code: 200,
  data: {
    token: "JWT token字符串",
    expire_time: "2025-12-31 23:59:59",  // token 过期时间
    openid: "用户的openid",
    unionid: "用户的unionid",
    wx_roles: [],           // 用户角色列表
    is_apply_acard: 0,      // 是否认证校友卡
    // ... 其他用户信息
  }
}
```

------

## 三、完整文件结构

复用此功能需要创建/修改以下文件：

```
project/
├── app.js                      # 小程序入口，引入 auth 模块
├── utils/
│   ├── auth.js                 # 核心认证模块
│   ├── api.js                  # API 接口定义
│   ├── request.js              # 请求封装（含加密）
│   ├── lib.js                  # 工具函数
│   └── Crypto/                 # 加密模块
│       ├── index.js            # 加密入口
│       ├── RandomStr.js        # 随机字符串生成
│       ├── base64.min.js       # base64 编解码
│       └── md5.min.js          # MD5 签名
```

------

## 四、核心代码文件

### 4.1 app.js（入口文件）

```javascript
// app.js
import lib from './utils/lib.js'
import auth from './utils/auth'

App({
  // 全局数据
  kVersionNum: '1.0',
  
  onLaunch(opt) {
    this.globalData.urlOpt = opt
    
    // 根据环境配置 baseUrl
    const accountInfo = wx.getAccountInfoSync();
    switch (accountInfo.miniProgram.envVersion) {
      case 'develop':
        this.globalData.baseUrl = 'https://your-dev-api.com'
        break;
      case 'trial':
        this.globalData.baseUrl = 'https://your-test-api.com'
        break;
      case 'release':
        this.globalData.baseUrl = 'https://your-prod-api.com'
        break;
      default:
        this.globalData.baseUrl = 'https://your-prod-api.com'
        break;
    }
  },
  
  onShow(options) {
    // 如果有邀请人参数，触发登录
    if (options.query && options.query.scene) {
      this.login(options.query.scene)
    }
  },
  
  userInfo: {
    token: ''
  },
  
  globalData: {
    baseUrl: '',
    apploaded: false,
    userData: {},      // 存储用户数据
    userConfig: {
      roles: {},
      is_apply_acard: 0
    }
  },
  
  // 将 auth 模块的方法混入 App 实例
  ...auth,
  ...lib
})
```

### 4.2 utils/auth.js（核心认证模块）

```javascript
// utils/auth.js
import {
  getUserInfo as get_user_info,
  init
} from './api.js'

// 判断时间是否过期
const judgeTime = (time) => {
  let strTime = time.replace("/-/g", "/");
  let date1 = new Date(strTime);
  let date2 = new Date();
  return date1 < date2;
}

// 检测登录状态，返回 true / false
function checkHasLogined() {
  const token = wx.getStorageSync('token')
  const expire_time = wx.getStorageSync('expire_time')
  
  // 判断是否过期
  if (expire_time && judgeTime(expire_time)) {
    wx.setStorageSync('token', '');
    wx.setStorageSync('expire_time', '');
    return false;
  }
  
  if (!token) {
    return false
  } else {
    return true;
  }
}

// 静默获取微信登录 code
async function wxaCode() {
  return new Promise((resolve, reject) => {
    wx.login({
      success(res) {
        return resolve(res.code)
      },
      fail() {
        wx.showToast({
          title: '静默登录失败',
          icon: 'none'
        })
        return resolve('登录失败')
      }
    })
  })
}

// 微信 session 检查
async function checkSession() {
  return new Promise((resolve, reject) => {
    wx.checkSession({
      success() {
        return resolve(true)
      },
      fail() {
        return resolve(false)
      }
    })
  })
}

/**
 * 核心登录函数
 * @param {string} inviter_wx_uuid - 可选，邀请人的 UUID
 * @returns {object} 用户数据
 */
async function login(inviter_wx_uuid) {
  console.log('邀请人的uuid', inviter_wx_uuid)
  
  // 1. 调用 wx.login 获取 code
  const wxcode = await wxaCode();
  
  // 2. 构建请求参数
  let params = {
    code: wxcode
  }
  
  // 如果有邀请人，加入参数
  inviter_wx_uuid && (params.inviter_wx_uuid = inviter_wx_uuid)
  
  // 3. 调用后端 wx_init 接口
  const {
    data: {
      data,
      code
    }
  } = await init(params)
  
  // 4. 处理返回结果
  if (code == 200) {
    // 存储 token 和过期时间
    wx.setStorageSync('token', data.token)
    wx.setStorageSync('expire_time', data.expire_time)
    
    // 存储用户数据到全局
    getApp().globalData.userData = data
    
    // 二次加工用户信息
    formatUserInfoData(data)
    
    return data
  } else {
    wx.showToast({
      title: '登陆失败',
    })
  }
}

// 获取/刷新用户信息
async function getUserInfo() {
  const {
    data: {
      data,
      code
    }
  } = await get_user_info()

  if (code == 200) {
    wx.setStorageSync('token', data.token)
    wx.setStorageSync('expire_time', data.expire_time)
    getApp().globalData.userData = data
    formatUserInfoData(data)
    return data
  } else {
    wx.showToast({
      title: '刷新用户信息失败',
    })
  }
}

/**
 * 初始化小程序 - 页面调用入口
 * 检查是否已登录，未登录则自动登录
 */
async function initApp() {
  let uinfoData = {}
  let isLogin = await checkHasLogined()
  
  if (isLogin) {
    uinfoData = getApp().globalData.userData
  } else {
    uinfoData = await this.login()
  }
  
  return uinfoData
}

// 二次加工用户信息（处理角色等）
function formatUserInfoData(userData) {
  let config_roles = {};
  
  userData && userData.wx_roles && userData.wx_roles.forEach(element => {
    let roleName = element.name
    config_roles[roleName] = true;
  });
  
  getApp().globalData.userConfig.roles = config_roles;
  getApp().globalData.userConfig.is_apply_acard = userData.is_apply_acard;
}

// 检测是否有某些角色
function checkHasRoles($arr) {
  const user_roles = getApp().globalData.userData.wx_roles || []
  for (let i = 0; i < user_roles.length; i++) {
    let name = user_roles[i].name;
    if ($arr.includes(name)) {
      return true;
    }
  }
  return false;
}

module.exports = {
  login,
  initApp,
  getUserInfo,
  checkHasLogined,
  checkHasRoles
};
```

### 4.3 utils/api.js（API 定义）

```javascript
// utils/api.js
import request from './request'

/**
 * 微信初始化接口 - 核心接口
 * 用 wx.login 的 code 换取 token 和用户信息
 */
export function init(data) {
  return request({
    url: '/api/wechat_mini/auth/wx_init',
    data
  })
}

/**
 * 获取/刷新用户信息
 */
export function getUserInfo(data) {
  return request({
    url: '/api/wechat_mini_v1/auth/get_user_info',
    data
  })
}

/**
 * 设置用户头像
 */
export function setUserAvatar(data) {
  return request({
    url: '/api/wechat_mini_v1/auth/set_user_avatar',
    data
  })
}
```

### 4.4 utils/request.js（请求封装）

```javascript
// utils/request.js
import base64 from './Crypto/base64.min';
import { crypto_param } from './Crypto/index'

const header = {
  'content-type': 'application/json',
};

const request = (params) => {
  const app = getApp()
  
  // 获取 token 并设置请求头
  let gtoken = wx.getStorageSync('token')
  if (gtoken) {
    header.Authorization = 'Bearer ' + gtoken
  } else {
    let uinfo = wx.getStorageSync('userInfo') || {}
    header.Authorization = 'Bearer ' + uinfo.token || ''
  }
  
  let data = params.data
  
  return new Promise((resolve, reject) => {
    let baseUrl = app.globalData.baseUrl
    
    wx.request({
      url: params.data && params.data.isAllUrl ? params.url : baseUrl + params.url,
      method: params.method || 'post',
      data: crypto_param(data, "") || {},  // 加密参数
      header,
      success: function (res) {
        let { code, msg } = res.data
        
        if (code == 200) {
          // 解密返回数据
          if (res.data.data) {
            try {
              res.data.data = JSON.parse(base64.decode(res.data.data))
            } catch {
              // 解密失败，保持原样
            }
          }
          resolve(res)
        } else if (code == 401) {
          // token 过期，清空登录状态
          wx.setStorageSync('token', '');
          wx.setStorageSync('expire_time', '');
          resolve(res);
        } else {
          msg && wx.showToast({
            icon: 'none',
            title: msg
          })
          resolve(res);
        }
      },
      fail: function (res) {
        console.log(res, '-----error--request网络错误----')
        wx.showToast({
          icon: 'none',
          title: '网络错误'
        })
        reject();
      }
    })
  })
}

export default request
```

### 4.5 utils/Crypto/index.js（加密模块）

```javascript
// utils/Crypto/index.js
const md5 = require('./md5.min');
const base64 = require('./base64.min');
import { RandomStr } from './RandomStr'

/**
 * 参数加密函数
 * 将请求参数进行 base64 编码 + MD5 签名
 */
export function crypto_param($param, $publicKey) {
  if (!isPlainObject($param)) { return false; }
  
  // 添加时间戳
  $param.timestamp = parseInt(new Date().getTime().toString());
  
  // 添加随机字符串
  const nonce_str = RandomStr(20);
  $param.nonce_str = nonce_str;
  
  // 克隆参数
  var _data = cloneObj($param);
  
  // base64 编码
  var $param_str = base64.encode(JSON.stringify(_data));
  
  // MD5 签名
  var $sign_str = md5($param_str);
  
  return {
    'params': _data,       // 原始参数
    'key_str': $param_str, // base64 编码后的字符串
    'sign_str': $sign_str  // MD5 签名
  };
}

// 判断是否为纯粹对象
function isPlainObject(obj) {
  if (!obj || obj.toString() !== "[object Object]" || obj.nodeType || obj.setInterval) {
    return false;
  }
  if (obj.constructor && !obj.hasOwnProperty("constructor") && !obj.constructor.prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  for (var key in obj) { }
  return key === undefined || obj.hasOwnProperty(key);
}

// 深拷贝对象
function cloneObj(obj) {
  if (!isPlainObject(obj)) { return false; }
  return JSON.parse(JSON.stringify(obj));
}
```

### 4.6 utils/Crypto/RandomStr.js

```javascript
// utils/Crypto/RandomStr.js
export function RandomStr($length) {
  let chars = 'ABCDFGHIJKLMNOPQRSTU1VWXYZabcdefghijklmnopqrstuvwxyz023456789E';
  let str = '';
  for (let i = 0; i < $length; i++) {
    str += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return str;
}
```

### 4.7 base64.min.js 和 md5.min.js

这两个文件是第三方库：

- **base64.min.js**: https://github.com/dankogai/js-base64 (v2.1.9)
- **md5.min.js**: https://github.com/blueimp/JavaScript-MD5 (v2.4.0)

直接从项目中复制即可使用。

------

## 五、页面中如何使用

### 5.1 在页面 onLoad 中初始化

```javascript
// pages/index/index.js
const app = getApp()

Page({
  data: {
    userInfo: {}
  },
  
  async onLoad() {
    // 调用初始化，自动处理登录
    const userData = await app.initApp()
    
    this.setData({
      userInfo: userData
    })
    
    console.log('用户信息:', userData)
  }
})
```

### 5.2 检查登录状态

```javascript
// 任意页面
const app = getApp()

// 检查是否已登录
if (app.checkHasLogined()) {
  console.log('已登录')
} else {
  console.log('未登录，需要初始化')
  await app.login()
}
```

### 5.3 获取用户数据

```javascript
const app = getApp()

// 从全局获取用户数据
const userData = app.globalData.userData

// 获取 token
const token = wx.getStorageSync('token')
```

------

## 六、后端需要实现的接口

### 6.1 `/api/wechat_mini/auth/wx_init` 接口

**后端处理逻辑：**

```
1. 接收前端传来的加密参数
2. 验证签名 (sign_str)
3. 解密 base64 参数
4. 用 code 调用微信接口获取 openid/unionid:
   - 调用: https://api.weixin.qq.com/sns/jscode2session
   - 参数: appid, secret, js_code, grant_type=authorization_code
5. 根据 openid 查找或创建用户记录
6. 生成 JWT token
7. 返回用户信息（base64 加密）
```

**微信接口调用示例（后端）：**

```python
# Python 示例
import requests

def get_wx_session(code):
    url = "https://api.weixin.qq.com/sns/jscode2session"
    params = {
        "appid": "你的小程序appid",
        "secret": "你的小程序secret",
        "js_code": code,
        "grant_type": "authorization_code"
    }
    response = requests.get(url, params=params)
    return response.json()
    # 返回: {"openid": "xxx", "session_key": "xxx", "unionid": "xxx"}
```

**返回格式：**

```javascript
// 返回数据需要 base64 加密
{
  code: 200,
  msg: "success",
  data: base64_encode(JSON.stringify({
    token: "eyJ...",
    expire_time: "2025-12-31 23:59:59",
    openid: "oXXXX",
    unionid: "oYYYY",
    wx_roles: [{ name: "user" }],
    is_apply_acard: 0,
    avatar: "https://...",
    nickname: "用户昵称"
  }))
}
```

### 6.2 请求参数加密/验签规则

**前端发送格式：**

```javascript
{
  params: {
    code: "xxx",
    timestamp: 1234567890,
    nonce_str: "ABCDabcd1234..."
  },
  key_str: "base64编码后的params",
  sign_str: "md5(key_str)"
}
```

**后端验签流程：**

```python
# Python 示例
import base64
import hashlib
import json

def verify_sign(request_data):
    key_str = request_data['key_str']
    sign_str = request_data['sign_str']
    
    # 计算 MD5
    calculated_sign = hashlib.md5(key_str.encode()).hexdigest()
    
    # 验证签名
    if calculated_sign != sign_str:
        return False, "签名错误"
    
    # 解码参数
    params = json.loads(base64.b64decode(key_str))
    
    return True, params
```

------

## 七、注意事项

### 7.1 token 过期处理

- token 过期时间存储在 `expire_time`
- 每次发请求前不会主动检查，而是在请求返回 401 时清空 token
- 页面需要在获取 401 后重新调用 `initApp()` 或 `login()`

### 7.2 环境配置

根据 `wx.getAccountInfoSync().miniProgram.envVersion` 判断环境：

- `develop` - 开发环境
- `trial` - 体验版
- `release` - 正式版

### 7.3 安全考虑

1. **传输加密**：请求参数使用 base64 + MD5 签名
2. **返回加密**：返回数据使用 base64 编码
3. **token 机制**：使用 JWT Bearer token

### 7.4 经纬度获取（如需要）

如果需要获取用户经纬度，需要额外调用：

```javascript
wx.getLocation({
  type: 'wgs84',
  success(res) {
    const latitude = res.latitude
    const longitude = res.longitude
    // 发送到后端
  }
})
```

**注意**：需要在 `app.json` 中配置权限：

```json
{
  "permission": {
    "scope.userLocation": {
      "desc": "你的位置信息将用于查找附近校友"
    }
  }
}
```

------

## 八、快速复用步骤

1. **复制文件**：将 `utils/` 目录下的所有文件复制到新项目
2. **修改 app.js**：引入 auth 和 lib 模块，配置 baseUrl
3. **修改 API 路径**：根据后端实际路径修改 `api.js` 中的接口地址
4. **后端实现接口**：实现 `wx_init` 接口，遵循上述加密/验签规则
5. **页面调用**：在需要的页面调用 `app.initApp()` 完成初始化

------

## 九、总结

**核心要点：**

1. 使用 `wx.login()` 静默获取 code，无需用户授权
2. 后端使用 code 换取 openid/unionid
3. 返回 JWT token 用于后续请求鉴权
4. 请求使用 base64 + MD5 加密签名
5. 响应数据使用 base64 编码

**调用的后端接口：**

| 接口          | 路径                                     | 说明            |
| ------------- | ---------------------------------------- | --------------- |
| wx_init       | `/api/wechat_mini/auth/wx_init`          | 初始化/静默登录 |
| get_user_info | `/api/wechat_mini_v1/auth/get_user_info` | 刷新用户信息    |

**Update Todos**

- 阅读 app.js 了解初始化入口
- 分析 wx_init 函数实现
- 分析相关 API 请求封装
- 分析加密模块
- 分析 lib.js 工具函数
- 整理后端接口列表
- 编写详细复用文档

文档已完成。以上是完整的微信小程序静默初始化复用文档，包含了：

1. **核心流程说明** - 整个初始化的工作原理
2. **后端接口清单** - 明确需要调用哪些接口
3. **完整代码文件** - 所有需要复制的文件及其内容
4. **加密/验签机制** - 详细的请求加密和响应解密规则
5. **后端实现指导** - 告诉后端如何配合实现
6. **使用示例** - 页面中如何调用
7. **快速复用步骤** - 简明的迁移指南

这份文档可以直接提供给其他 AI agent 或前端开发者，按照步骤即可完成复用。